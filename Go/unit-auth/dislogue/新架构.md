# ä¸­å¿ƒåŒ–SSOç™»å½•ç³»ç»Ÿæ¶æ„è®¾è®¡æ–‡æ¡£ï¼ˆåç«¯Refresh Tokenæ–¹æ¡ˆï¼‰

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯
- **æ–‡æ¡£ç‰ˆæœ¬**: v2.0
- **åˆ›å»ºæ—¥æœŸ**: 2024å¹´1æœˆ15æ—¥
- **æœ€åæ›´æ–°**: 2024å¹´1æœˆ15æ—¥
- **ä½œè€…**: AIæ¶æ„åŠ©æ‰‹
- **çŠ¶æ€**: å®šç¨¿

## ğŸ¯ æ¶æ„æ ¸å¿ƒåŸåˆ™

### **å®‰å…¨ç¬¬ä¸€åŸåˆ™**
- ğŸ”’ **Refresh Tokenæ°¸ä¸ç¦»å¼€åç«¯**
- ğŸ” **å‰ç«¯åªæ¥è§¦çŸ­æœŸAccess Token**
- ğŸ›¡ï¸ **ä¸­å¿ƒåŒ–ä¼šè¯ç®¡ç†**
- ğŸ“Š **å®Œæ•´çš„å®¡è®¡æ—¥å¿—**

## ğŸ—ï¸ ä¼˜åŒ–åçš„ç³»ç»Ÿæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   åº”ç”¨A     â”‚    â”‚ ä¸­å¿ƒSSOç³»ç»Ÿ  â”‚    â”‚   åº”ç”¨B     â”‚
â”‚  å‰ç«¯       â”‚    â”‚             â”‚    â”‚  å‰ç«¯       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚Access â”‚  â”‚    â”‚  â”‚ç™»å½•é¡µ â”‚  â”‚    â”‚  â”‚Access â”‚  â”‚
â”‚  â”‚Token  â”‚â—„â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”‚é¢    â”‚  â”‚    â”‚  â”‚Token  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚             â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚  â”‚Token  â”‚  â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   åº”ç”¨A     â”‚    â”‚  â”‚åˆ·æ–°æœåŠ¡â”‚  â”‚    â”‚   åº”ç”¨B     â”‚
â”‚  åç«¯       â”‚â”€â”€â”€â”€â”¼â”€â”€â–º       â”‚â—„â”€â”¼â”€â”€â”€â”€â”‚  åç«¯       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚Auth   â”‚  â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚  â”‚Auth   â”‚  â”‚
â”‚  â”‚ä¸­é—´ä»¶  â”‚  â”‚    â”‚  â”‚Sessionâ”‚  â”‚    â”‚  â”‚ä¸­é—´ä»¶  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚  â”‚ç®¡ç†    â”‚  â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚    æ•°æ®å­˜å‚¨å±‚       â”‚
                     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
                     â”‚  â”‚  sessions   â”‚  â”‚
                     â”‚  â”‚    è¡¨       â”‚  â”‚
                     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”„ æ ¸å¿ƒæµç¨‹è®¾è®¡

### **1. é¦–æ¬¡ç™»å½•æµç¨‹**
```mermaid
sequenceDiagram
    participant U as ç”¨æˆ·
    participant A as åº”ç”¨Aå‰ç«¯
    participant AB as åº”ç”¨Aåç«¯
    participant SSO as ä¸­å¿ƒSSO
    participant DB as æ•°æ®åº“

    U->>A: è®¿é—®åº”ç”¨A
    A->>SSO: é‡å®šå‘åˆ°ç™»å½•é¡µ
    U->>SSO: è¾“å…¥å‡­è¯ç™»å½•
    SSO->>DB: åˆ›å»ºsessionè®°å½•
    SSO->>DB: ç”Ÿæˆå¹¶å­˜å‚¨refresh_token
    SSO->>A: è¿”å›access_token(çŸ­æœŸ)
    A->>AB: æºå¸¦access_tokenè®¿é—®API
    AB->>AB: æœ¬åœ°JWTéªŒè¯(é€šè¿‡)
    AB->>U: è¿”å›ä¸šåŠ¡æ•°æ®
```

### **2. Tokenè‡ªåŠ¨åˆ·æ–°æµç¨‹**
```mermaid
sequenceDiagram
    participant U as ç”¨æˆ·
    participant A as åº”ç”¨Aå‰ç«¯
    participant AB as åº”ç”¨Aåç«¯
    participant SSO as ä¸­å¿ƒSSO
    participant DB as æ•°æ®åº“

    U->>A: å‘èµ·APIè¯·æ±‚
    A->>AB: æºå¸¦access_token(å·²è¿‡æœŸ)
    AB->>AB: æœ¬åœ°éªŒè¯å‘ç°tokenè¿‡æœŸ
    AB->>SSO: è¯·æ±‚åˆ·æ–°token(æºå¸¦è¿‡æœŸtoken)
    SSO->>DB: éªŒè¯sessionçŠ¶æ€
    SSO->>DB: ä½¿ç”¨refresh_tokenç”Ÿæˆæ–°access_token
    SSO->>AB: è¿”å›æ–°access_token
    AB->>AB: ä½¿ç”¨æ–°tokenå¤„ç†ä¸šåŠ¡é€»è¾‘
    AB->>U: è¿”å›ä¸šåŠ¡æ•°æ®(å‰ç«¯æ— æ„ŸçŸ¥åˆ·æ–°)
```

### **3. SSOæµç¨‹ï¼ˆåº”ç”¨Bï¼‰**
```mermaid
sequenceDiagram
    participant U as ç”¨æˆ·
    participant B as åº”ç”¨Bå‰ç«¯
    participant BB as åº”ç”¨Båç«¯
    participant SSO as ä¸­å¿ƒSSO
    participant DB as æ•°æ®åº“

    U->>B: è®¿é—®åº”ç”¨B
    B->>SSO: æ£€æŸ¥æµè§ˆå™¨session
    SSO->>DB: éªŒè¯sessionæœ‰æ•ˆæ€§
    SSO->>B: ç”Ÿæˆåº”ç”¨Bä¸“å±access_token
    B->>BB: æºå¸¦tokenè®¿é—®API
    BB->>BB: æœ¬åœ°JWTéªŒè¯
    BB->>U: è¿”å›ä¸šåŠ¡æ•°æ®(è‡ªåŠ¨ç™»å½•)
```

## ğŸ’¾ ç®€åŒ–çš„æ•°æ®åº“è®¾è®¡

### **æ ¸å¿ƒè¡¨ï¼šsessionsï¼ˆä¼šè¯ç®¡ç†ï¼‰**
```sql
CREATE TABLE sessions (
    -- ä¸»é”®æ ‡è¯†
    id BIGSERIAL PRIMARY KEY,
    session_id VARCHAR(128) UNIQUE NOT NULL,
    user_id VARCHAR(64) NOT NULL,
    
    -- Tokenç®¡ç†ï¼ˆå“ˆå¸Œå­˜å‚¨ï¼‰
    current_access_token_hash VARCHAR(256),
    refresh_token_hash VARCHAR(256) NOT NULL,
    
    -- çŠ¶æ€ç®¡ç†
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ NOT NULL,
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    last_refresh_at TIMESTAMPTZ,
    
    -- å®‰å…¨ä¿¡æ¯
    user_agent TEXT,
    ip_address INET,
    device_fingerprint VARCHAR(128),
    
    -- åº”ç”¨ä¸Šä¸‹æ–‡
    current_app_id VARCHAR(64),
    
    -- ç´¢å¼•ä¼˜åŒ–
    INDEX idx_sessions_user (user_id),
    INDEX idx_sessions_expiry (expires_at),
    INDEX idx_sessions_activity (last_activity),
    INDEX idx_sessions_status (status)
);
```

### **è¾…åŠ©è¡¨ï¼štoken_refresh_logsï¼ˆå®¡è®¡æ—¥å¿—ï¼‰**
```sql
CREATE TABLE token_refresh_logs (
    id BIGSERIAL PRIMARY KEY,
    session_id VARCHAR(128) NOT NULL,
    user_id VARCHAR(64) NOT NULL,
    app_id VARCHAR(64) NOT NULL,
    old_token_hash VARCHAR(256),
    new_token_hash VARCHAR(256),
    refreshed_at TIMESTAMPTZ DEFAULT NOW(),
    user_agent TEXT,
    ip_address INET,
    success BOOLEAN NOT NULL,
    error_reason VARCHAR(64),
    
    INDEX idx_refresh_logs_session (session_id),
    INDEX idx_refresh_logs_user (user_id),
    INDEX idx_refresh_logs_time (refreshed_at)
);
```

## ğŸ”§ æ ¸å¿ƒç»„ä»¶å®ç°

### **1. ä¸­å¿ƒSSOæœåŠ¡ - Tokenåˆ·æ–°æœåŠ¡**
```python
class CentralTokenRefreshService:
    async def refresh_access_token(self, expired_token: str, app_id: str, 
                                 request_metadata: dict) -> dict:
        """
        ä¸­å¿ƒåŒ–tokenåˆ·æ–° - åç«¯è°ƒç”¨
        """
        try:
            # 1. è§£æè¿‡æœŸtokenè·å–session_idï¼ˆå¿½ç•¥è¿‡æœŸï¼‰
            session_id = self.decode_session_id_ignore_expiry(expired_token)
            if not session_id:
                return self.error_response("invalid_token")
            
            # 2. å•æ¬¡æŸ¥è¯¢è·å–å®Œæ•´ä¼šè¯ä¿¡æ¯
            session = await self.get_session_with_validation(session_id)
            if not session:
                return self.error_response("session_invalid")
            
            # 3. å®‰å…¨æ£€æŸ¥
            security_check = await self.security_validation(session, request_metadata)
            if not security_check["passed"]:
                await self.handle_security_incident(session, security_check["reason"])
                return self.error_response("security_validation_failed")
            
            # 4. æ»‘åŠ¨ç»­ç­¾æ£€æŸ¥
            await self.sliding_renewal_check(session)
            
            # 5. ç”Ÿæˆæ–°token
            new_token = await self.generate_new_access_token(session, app_id)
            
            # 6. æ›´æ–°ä¼šè¯è®°å½•
            await self.update_session_tokens(session, new_token)
            
            # 7. è®°å½•å®¡è®¡æ—¥å¿—
            await self.log_refresh_operation(session, app_id, request_metadata)
            
            return {
                "success": True,
                "access_token": new_token,
                "expires_in": config.ACCESS_TOKEN_EXPIRY,
                "token_type": "Bearer"
            }
            
        except Exception as e:
            logger.error(f"Token refresh error: {e}")
            return self.error_response("server_error")
    
    async def get_session_with_validation(self, session_id: str):
        """å•æ¬¡æŸ¥è¯¢å®Œæˆæ‰€æœ‰éªŒè¯"""
        session = await self.db.fetch_one("""
            SELECT s.*, u.status as user_status, u.login_count
            FROM sessions s 
            JOIN users u ON s.user_id = u.user_id
            WHERE s.session_id = $1 
            AND s.status = 'active'
            AND s.expires_at > NOW()
            AND u.status = 'active'
        """, session_id)
        return session
```

### **2. å­åº”ç”¨åç«¯ - ç»Ÿä¸€è®¤è¯ä¸­é—´ä»¶**
```python
class SSOAuthMiddleware:
    """å­åº”ç”¨åç«¯è®¤è¯ä¸­é—´ä»¶"""
    
    def __init__(self, app, sso_client):
        self.app = app
        self.sso_client = sso_client
        
    async def __call__(self, scope, receive, send):
        if scope["type"] != "http":
            return await self.app(scope, receive, send)
        
        request = Request(scope, receive)
        
        # è·³è¿‡å…¬å¼€ç«¯ç‚¹
        if self.is_public_endpoint(request):
            return await self.app(scope, receive, send)
        
        # æå–token
        access_token = self.extract_access_token(request)
        if not access_token:
            return await self.unauthorized_response(send, "missing_token")
        
        # éªŒè¯token
        auth_result = await self.authenticate_request(access_token, request)
        
        if auth_result["authenticated"]:
            # è®¤è¯æˆåŠŸï¼Œç»§ç»­å¤„ç†
            return await self.proceed_with_authentication(
                scope, receive, send, auth_result
            )
        else:
            # è®¤è¯å¤±è´¥
            return await self.handle_authentication_failure(send, auth_result)
    
    async def authenticate_request(self, access_token: str, request: Request) -> dict:
        """è®¤è¯è¯·æ±‚"""
        try:
            # 1. æœ¬åœ°å¿«é€ŸJWTéªŒè¯
            validation = self.validate_token_locally(access_token)
            
            if validation["valid"]:
                return {
                    "authenticated": True,
                    "user_info": validation["payload"],
                    "needs_refresh": False
                }
            elif validation["expired"]:
                # 2. Tokenè¿‡æœŸï¼Œå°è¯•åˆ·æ–°
                return await self.handle_token_refresh(access_token, request)
            else:
                return {
                    "authenticated": False,
                    "error": "token_invalid",
                    "message": "Token validation failed"
                }
                
        except Exception as e:
            logger.error(f"Authentication error: {e}")
            return {
                "authenticated": False,
                "error": "authentication_error",
                "message": str(e)
            }
    
    async def handle_token_refresh(self, expired_token: str, request: Request) -> dict:
        """å¤„ç†tokenåˆ·æ–°"""
        refresh_result = await self.sso_client.refresh_token(
            expired_token=expired_token,
            app_id=self.app_id,
            user_agent=request.headers.get("user-agent"),
            ip_address=self.get_client_ip(request)
        )
        
        if refresh_result["success"]:
            # åˆ·æ–°æˆåŠŸï¼Œæ›´æ–°è¯·æ±‚ä¸­çš„token
            new_token = refresh_result["access_token"]
            user_info = self.decode_token(new_token)
            
            return {
                "authenticated": True,
                "user_info": user_info,
                "needs_refresh": True,
                "new_token": new_token
            }
        else:
            return {
                "authenticated": False,
                "error": "token_refresh_failed",
                "message": refresh_result.get("error", "Refresh failed")
            }
```

### **3. å®‰å…¨ç›‘æ§æœåŠ¡**
```python
class SecurityMonitor:
    """å®‰å…¨ç›‘æ§å’Œå¼‚å¸¸æ£€æµ‹"""
    
    async def validate_refresh_request(self, session: dict, request_metadata: dict) -> dict:
        """éªŒè¯åˆ·æ–°è¯·æ±‚çš„å®‰å…¨æ€§"""
        checks = {
            "device_consistency": await self.check_device_consistency(session, request_metadata),
            "refresh_frequency": await self.check_refresh_frequency(session),
            "geolocation_consistency": await self.check_geolocation_consistency(session, request_metadata),
            "user_agent_analysis": await self.analyze_user_agent(session, request_metadata)
        }
        
        passed = all(checks.values())
        risk_score = self.calculate_risk_score(checks)
        
        return {
            "passed": passed,
            "risk_score": risk_score,
            "details": checks
        }
    
    async def check_refresh_frequency(self, session: dict) -> bool:
        """æ£€æŸ¥åˆ·æ–°é¢‘ç‡"""
        recent_refreshes = await self.db.fetch_val("""
            SELECT COUNT(*) FROM token_refresh_logs 
            WHERE session_id = $1 
            AND refreshed_at > NOW() - INTERVAL '1 hour'
        """, session["session_id"])
        
        return recent_refreshes < config.MAX_HOURLY_REFRESHES
```

## ğŸŒ APIæ¥å£è§„èŒƒ

### **ä¸­å¿ƒSSOç³»ç»ŸAPI**
```http
# 1. Tokenåˆ·æ–°æ¥å£ï¼ˆåç«¯è°ƒç”¨ï¼‰
POST /api/v1/token/refresh
Content-Type: application/json
X-App-ID: your_app_id
X-App-Secret: your_app_secret

{
  "expired_token": "eyJ...",
  "user_agent": "Mozilla/5.0...",
  "ip_address": "192.168.1.100"
}

å“åº”ï¼š
{
  "success": true,
  "access_token": "new_jwt_token",
  "expires_in": 3600,
  "token_type": "Bearer"
}

# 2. ä¼šè¯éªŒè¯æ¥å£
POST /api/v1/session/validate
Content-Type: application/json

{
  "session_id": "session_abc",
  "app_id": "app_a"
}

# 3. ç”¨æˆ·ç™»å‡ºæ¥å£
POST /api/v1/session/logout
Content-Type: application/json

{
  "session_id": "session_abc",
  "logout_type": "global"  // or "single"
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### **1. ç¼“å­˜ç­–ç•¥**
```python
class TokenValidationCache:
    """TokenéªŒè¯ç¼“å­˜"""
    
    def __init__(self, redis_client):
        self.redis = redis_client
        self.cache_ttl = 300  # 5åˆ†é’Ÿ
    
    async def get_cached_validation(self, token_hash: str) -> Optional[dict]:
        """è·å–ç¼“å­˜éªŒè¯ç»“æœ"""
        cached = await self.redis.get(f"token_valid:{token_hash}")
        return json.loads(cached) if cached else None
    
    async def cache_validation_result(self, token_hash: str, result: dict):
        """ç¼“å­˜éªŒè¯ç»“æœ"""
        await self.redis.setex(
            f"token_valid:{token_hash}",
            self.cache_ttl,
            json.dumps(result)
        )
```

### **2. æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–**
```sql
-- ä½¿ç”¨è¦†ç›–ç´¢å¼•å‡å°‘å›è¡¨
CREATE INDEX idx_sessions_validation ON sessions 
(session_id, status, expires_at, user_id) 
INCLUDE (current_access_token_hash, refresh_token_hash);
```

## ğŸš€ éƒ¨ç½²å’Œæ‰©å±•æ€§

### **å¾®æœåŠ¡æ¶æ„éƒ¨ç½²**
```yaml
# docker-compose.prod.yml
version: '3.8'
services:
  sso-api:
    image: sso-center:latest
    deploy:
      replicas: 3
    environment:
      - DB_URL=postgresql://user:pass@db:5432/sso
      - REDIS_URL=redis://redis:6379
      - JWT_PUBLIC_KEY=/run/secrets/jwt_public
    secrets:
      - jwt_private
      - jwt_public
  
  sso-gateway:
    image: nginx:alpine
    ports:
      - "443:443"
    configs:
      - source: nginx.conf
        target: /etc/nginx/nginx.conf

configs:
  nginx.conf:
    file: ./config/nginx.conf

secrets:
  jwt_private:
    file: ./secrets/jwt_private.pem
  jwt_public:
    file: ./secrets/jwt_public.pem
```

## ğŸ“Š ç›‘æ§æŒ‡æ ‡

### **å…³é”®æ€§èƒ½æŒ‡æ ‡**
```python
# PrometheusæŒ‡æ ‡å®šä¹‰
SSO_METRICS = {
    "sso_token_validations_total": "TokenéªŒè¯æ€»æ¬¡æ•°",
    "sso_token_refreshes_total": "Tokenåˆ·æ–°æ€»æ¬¡æ•°", 
    "sso_refresh_success_rate": "åˆ·æ–°æˆåŠŸç‡",
    "sso_session_duration_seconds": "ä¼šè¯æŒç»­æ—¶é—´",
    "sso_active_sessions": "æ´»è·ƒä¼šè¯æ•°",
    "sso_security_incidents_total": "å®‰å…¨äº‹ä»¶æ•°"
}
```

## âœ… æ¶æ„ä¼˜åŠ¿æ€»ç»“

### **å®‰å…¨æ€§ä¼˜åŠ¿**
- âœ… **Refresh Tokenåç«¯å®‰å…¨å­˜å‚¨**
- âœ… **å‰ç«¯æ— æ•æ„Ÿä¿¡æ¯æ³„éœ²é£é™©**
- âœ… **ä¸­å¿ƒåŒ–å®‰å…¨ç­–ç•¥æ‰§è¡Œ**
- âœ… **å®Œæ•´çš„å®¡è®¡æ—¥å¿—**

### **æ€§èƒ½ä¼˜åŠ¿**
- âœ… **æœ¬åœ°JWTéªŒè¯å‡å°‘ç½‘ç»œå¼€é”€**
- âœ… **å•æ¬¡æ•°æ®åº“æŸ¥è¯¢å®Œæˆåˆ·æ–°**
- âœ… **ç¼“å­˜ä¼˜åŒ–æå‡å“åº”é€Ÿåº¦**

### **è¿ç»´ä¼˜åŠ¿**
- âœ… **ç»Ÿä¸€çš„å®‰å…¨ç›‘æ§**
- âœ… **ç®€åŒ–çš„æ•°æ®åº“ç»“æ„**
- âœ… **æ˜“äºæ‰©å±•å’Œç»´æŠ¤**

è¿™ä¸ªæ¶æ„æ—¢ä¿è¯äº†å®‰å…¨æ€§ï¼Œåˆæä¾›äº†è‰¯å¥½çš„æ€§èƒ½å’Œå¯ç»´æŠ¤æ€§ã€‚Refresh Tokenå®Œå…¨ç”±åç«¯ç®¡ç†ï¼Œå‰ç«¯åªå¤„ç†çŸ­æœŸæœ‰æ•ˆçš„Access Tokenï¼Œç¬¦åˆä¼ä¸šçº§å®‰å…¨è¦æ±‚ã€‚